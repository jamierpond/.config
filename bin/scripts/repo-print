#!/bin/bash
set -euo pipefail

# Usage: ./script.sh py ts js [--exclude pattern] [--exclude pattern2]

#git_root=$(git rev-parse --show-toplevel)
#cd "$git_root"

# Parse arguments
extensions=()
extra_excludes=()
parsing_excludes=false
while [ $# -gt 0 ]; do
    case "$1" in
        --exclude|-e)
            parsing_excludes=true
            shift
            ;;
        *)
            if $parsing_excludes; then
                extra_excludes+=("$1")
            else
                extensions+=("$1")
            fi
            shift
            ;;
    esac
done

# Debug: show parsed args
# echo "Extensions: ${extensions[*]}"
# echo "Excludes: ${extra_excludes[*]+"${extra_excludes[*]}"}"

total_lines=0
total_chars=0
file_locs=""

echo "### Repo tree:"
tree_output=$(git ls-files | tree --fromfile)
echo "$tree_output"
tree_lines=$(echo "$tree_output" | wc -l | tr -d ' ')
total_lines=$((total_lines + tree_lines + 2))
total_chars=$((total_chars + ${#tree_output} + 20))
echo

if [ ${#extensions[@]} -eq 0 ]; then
    echo "No file searches provided."
    size=$(echo "scale=2; $total_chars / 1024" | bc)
    echo "Total: $total_lines lines ($tree_lines tree), $total_chars chars ($size KB)" >&2
    exit 0
fi

pattern=$(printf "|%s" "${extensions[@]}")
pattern=${pattern:1}

# Files to exclude (lock files, generated files, etc.)
exclude_pattern="pnpm-lock\.yaml|package-lock\.json|yarn\.lock|go\.mod|go\.sum|Cargo\.lock|poetry\.lock|Gemfile\.lock|composer\.lock|\.min\.js|\.min\.css|dist/|build/|node_modules/|vendor/"

# Add extra excludes from command line
for ex in "${extra_excludes[@]+"${extra_excludes[@]}"}"; do
    exclude_pattern="$exclude_pattern|$ex"
done

matches=$(git ls-files | grep -E "$pattern" | grep -Ev "$exclude_pattern" || true)

if [ -z "$matches" ]; then
    echo "No files found with the specified search string: $*"
    size=$(echo "scale=2; $total_chars / 1024" | bc)
    echo "Total: $total_lines lines ($tree_lines tree), $total_chars chars ($size KB)" >&2
    exit 0
fi

while IFS= read -r file; do
    # Check MIME type, only include text/* files
    mime=$(file --mime-type -b "$file")
    if [[ "$mime" == text/* || "$mime" == application/json ]]; then
        echo -e "\n"
        echo -e "\n#########################"
        echo -e "### $file"
        cat "$file"
        file_lines=$(wc -l < "$file")
        file_chars=$(wc -c < "$file")
        file_locs="${file_locs}${file_lines}:${file}"$'\n'
        total_lines=$((total_lines + file_lines + 4))
        total_chars=$((total_chars + file_chars + 30 + ${#file}))
    else
        echo -e "\n### Skipping binary: $file (mime: $mime)"
        total_lines=$((total_lines + 2))
        total_chars=$((total_chars + 30 + ${#file} + ${#mime}))
    fi
done <<< "$matches"

# Print LOC summary
if [ -n "$file_locs" ]; then
    echo -e "\n\n#########################"
    echo -e "### Lines of Code:"
    total_loc=0
    loc_count=0
    footer_chars=0
    while IFS=':' read -r loc file; do
        if [ -n "$loc" ]; then
            printf "%6d  %s\n" "$loc" "$file"
            total_loc=$((total_loc + loc))
            loc_count=$((loc_count + 1))
            footer_chars=$((footer_chars + ${#file} + 10))
        fi
    done <<< "$(echo "$file_locs" | sort -t: -k1 -n)"
    echo "-----------------------------------"
    printf "Total Lines of Code: %d\n" "$total_loc"
    loc_section_lines=$((loc_count + 4))
    total_lines=$((total_lines + loc_section_lines))
    total_chars=$((total_chars + footer_chars + 50))
fi

if [ "$total_chars" -ge 1048576 ]; then
    size=$(echo "scale=2; $total_chars / 1048576" | bc)
    unit="MB"
else
    size=$(echo "scale=2; $total_chars / 1024" | bc)
    unit="KB"
fi

echo "Total: $total_lines lines ($tree_lines tree), $total_chars chars ($size $unit)" >&2

