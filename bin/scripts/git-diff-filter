#!/bin/bash
set -euo pipefail

# git diff wrapper with filtering options
# Usage: git-diff-filter <ref> [OPTIONS]

skip_above=""
only_additions=false
only_removals=false
excludes=()
ref=""

show_help() {
    cat <<EOF
Usage: gd <ref> [OPTIONS]

Arguments:
  ref                    Git ref to diff against (branch, commit, tag)

Options:
  -s, --skip-above N     Skip files with more than N lines changed
  -a, --only-additions   Only show added lines (+ lines)
  -r, --only-removals    Only show removed lines (- lines)
  -e, --exclude PATTERN  Exclude files matching PATTERN (can be used multiple times)
  -h, --help             Show this help message

Examples:
  gd main                 Diff against main
  gd main -s 2000         Skip files with >2000 lines changed
  gd HEAD~3 -a            Only show additions since 3 commits ago
  gd v1.0.0 -r            Only show removals since tag
  gd main -e test -e mock Exclude files matching patterns
EOF
    exit 0
}

# First arg should be the ref (unless it's -h)
if [ $# -eq 0 ] || [ "$1" = "-h" ] || [ "$1" = "--help" ]; then
    show_help
fi

ref="$1"
shift

# Parse remaining arguments
while [ $# -gt 0 ]; do
    case "$1" in
        -h|--help)
            show_help
            ;;
        -s|--skip-above)
            skip_above="$2"
            shift 2
            ;;
        -a|--only-additions)
            only_additions=true
            shift
            ;;
        -r|--only-removals)
            only_removals=true
            shift
            ;;
        -e|--exclude)
            excludes+=("$2")
            shift 2
            ;;
        *)
            echo "Unknown option: $1"
            exit 1
            ;;
    esac
done

# Build exclude pattern for grep
exclude_pattern=""
for ex in "${excludes[@]+${excludes[@]}}"; do
    if [ -z "$exclude_pattern" ]; then
        exclude_pattern="$ex"
    else
        exclude_pattern="$exclude_pattern|$ex"
    fi
done

# Get the diff output
diff_output=$(git diff "$ref")

if [ -z "$diff_output" ]; then
    echo "No changes"
    exit 0
fi

# Process the diff
current_file=""
current_block=""
file_line_count=0

process_block() {
    if [ -z "$current_block" ]; then
        return
    fi

    # Check if file matches exclude pattern
    if [ -n "$exclude_pattern" ] && echo "$current_file" | grep -Eq "$exclude_pattern"; then
        return
    fi

    # Check if we should skip based on line count
    if [ -n "$skip_above" ] && [ "$file_line_count" -gt "$skip_above" ]; then
        echo "--- Skipping $current_file ($file_line_count lines) ---"
        return
    fi

    # Filter based on additions/removals
    if $only_additions || $only_removals; then
        filtered_block=""
        while IFS= read -r line; do
            # Always keep headers and context
            if [[ "$line" =~ ^(diff|index|---|[+]{3}|@@|Binary) ]] || [[ ! "$line" =~ ^[+-] ]]; then
                filtered_block+="$line"$'\n'
            elif $only_additions && [[ "$line" =~ ^[+] ]]; then
                filtered_block+="$line"$'\n'
            elif $only_removals && [[ "$line" =~ ^[-] ]]; then
                filtered_block+="$line"$'\n'
            fi
        done <<< "$current_block"
        echo -n "$filtered_block"
    else
        echo -n "$current_block"
    fi
}

while IFS= read -r line; do
    # Detect new file
    if [[ "$line" =~ ^diff\ --git ]]; then
        # Process previous block
        process_block

        # Reset for new file
        current_file=$(echo "$line" | sed 's/diff --git a\/\(.*\) b\/.*/\1/')
        current_block="$line"$'\n'
        file_line_count=0
    else
        current_block+="$line"$'\n'
        # Count actual change lines (+ or -)
        if [[ "$line" =~ ^[+-] ]] && [[ ! "$line" =~ ^(---|[+]{3}) ]]; then
            ((file_line_count++)) || true
        fi
    fi
done <<< "$diff_output"

# Process last block
process_block
